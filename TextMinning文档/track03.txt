03:
本挖掘算法自身有一个属性：一个序列的前缀的计数必然大于该序列的次数。若前缀的计数等于该序列的次数，则前缀不应该单独被挖掘出，应被
包含在该序列的次数信息中。
来看一个很不明朗的问题：
使用了纯净计数（如原串为 aaaaa，'aa'的纯净计数为2次，非纯净计数为4次。即纯净计数情况下不允许一个位置被多个匹配同时占用）的
挖掘结果可能会出现无法预计的结果：
如：对于原串：aaabaaa，支持度2，使用纯净计数的情况下，得到以下结果：
a : 6
aaa : 2
aa : 2
从结果的表面上看，这是一个不可能出现的局面，因为算法本身的属性决定了，一切前缀字符串的次数如果与母串的次数一样，则这个前缀字符串是不会
被挖掘出的，也不应该被挖出。
之所以会得到这样的结果，并不是算法本身的问题，而是发生了巧合：使用了纯净计数的较长序列的个数碰巧与它的前缀的纯净计数相等。
这个问题的解决方法是：将次数相等的前缀串从频繁序列集合中去掉。


c : 频繁序列次数
	f : 频繁序列
	m : 频繁序列长度

	
	上一轮迭代：
	c1, f1, m1

	本轮迭代：
	c2, f2, m2
	
	下一轮迭代：
	c3, f3, m3

	-----------------------------------------------------------
	在不考虑纯净计数的情况下有：
	c1 > c2 > c3
	m1 < m2 < m3
	f1 -> f2 -> f3	(f1 是 f2 的前缀，f2 是 f3 的前缀)
	-----------------------------------------------------------

	当考虑纯净计数的情况时：
	c1 >= c2 >= c3
	m1 < m2 < m3
	f1 -> f2 -> f3	(f1 是 f2 的前缀，f2 是 f3 的前缀)

	故不可能存在 c1 与 c3 相等，而与 c2 不相等。
	导出的结论是：
	当考虑纯净计数时，为了去掉次数相同的两个序列：一个序列是另一个序列的前缀，
	只需要对相邻的迭代调用控制：
		上一次加入的频繁序列若与这次加入的序列的次数相同即抛弃前面加入的一个(它是本次频繁序列的前缀)。
	
	-----------------------------------------------------------

	注意 curNode 一定是已经使用纯净计数后的频繁序列。

	使用一个缓存机制：接受到一个频繁序列时，不真正地加入，而是等下一个频繁序列到来，比较次数是否
	相同，若相同则丢弃前一个，更新“前一个”，返回。否则加入前一个，更新“前一个”，返回。

	注意 pureCountExAddFps 连接的两次调用不仅仅会出现在 doGetFSOrderly 前后两次纵深迭代中，
	还会出现在 doGetFSOrderly 中的两个平行分支 doGetFSOrderly 中：一条分支的迭代完毕，切换到另一
	条分支的迭代上。但是上面的逻辑只适用于前后两次纵深迭代，不适应于后者。
	处理方法：
		pureCountExAddFps 增加逻辑：当 curNode 为 NULL 时视作一种“迭代完毕通知”，此时可以做两件事
			a)如果缓存中还有没有加入的频繁序列(即 _lastAddInNode 不为 NULL)则直接加入
			b)设置 _lastAddInNode 为 NULL
		然后在一次 doGetFSOrderly 迭代完毕之时调用 pureCountExAddFps(NULL) 即可。